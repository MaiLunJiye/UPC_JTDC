> 2017-01-30 20:45

由于查文档发现原生的JavaNIO 有很大的问题，而且编程要求太高，所以放弃了。可以说是一种甩锅行为，现在也要用到框架了

目前展示决定是用 `Netty` 框架，不过这个，希望这个框架简单点吧

*****

> 2017.1.26 9:06

还在测试第一种跳变方法，目前发现是 服务器端没有办法发送数据

发现一个细节错误，  InetSockaddr的比较 要用equals 函数，这个解决了资源占用问题

> 2017.1.24 19:47

新的思路：

关于内存占用问题，可能是每次跳变都需要新建一个`InetSocketAddr` 对象，然而Java的内存回收机制是不可靠的，所以寻求以下的方法

1. 把`InetSocketAddr`对象复用，但是`InetSocketAddr`对象好像没有`set`方法
2. 把可用的情况都申请一个`InetSocketAddr`并且存放，这样就不用每次跳变都申请一个对象。

这里考虑到C和Java的差别

**************************************

> 2017.1.24 10:25

**第一次跳变方法总结**

第一次跳变方法的思路：

1. 开启一个子线程，然后子线程进行同步
2. 主线程只是调用send，等函数发送信息

**情况**

无法正常通信，而且出现了资源占用过高情况

失败原因猜想：

1. 子线程同步时候多次绑定一个相同的端口，直接导致了通信失败（端口被断开后有可能不能马上再次被使用）
2. 子线程负责同步，主线程负责IO，但是两个线程同步问题没有考虑进去


******************************

> 2017.1.23 11:31

没有尝试修复前面的问题，而是接着开发测试代码，查看一下端口重复绑定会不会影响

结果是无法正常通信，同步策略需要更改

******************************

> 2017.1.23 11:14

跳变类依然出现端口重复绑定错误

```
java.net.SocketException: Already bound
	at sun.nio.ch.Net.translateToSocketException(Net.java:125)
	at sun.nio.ch.DatagramSocketAdaptor.bind(DatagramSocketAdaptor.java:93)
	at Transport.Jump_UDP.run(Jump_UDP.java:110)
	at java.lang.Thread.run(Thread.java:745)
```

测试发现虽然get到了不同的value值，但是通过这个值算出来的端口，ip都没有改变，因此出现了重复绑定的问题
