> 2017-03-07 20:10

完成一个 传统IO 的 线程池 图片传送 服务器


> 2017-03-07 19:52

**目前遇到问题总结:**
enqi
1. java 无法操作底层,不能对已经申请到的`Socket` 类重新设置 端口和地址,除非从新申请,但由于java内存回收机制的缺陷,会造成内存不足
2. java 原生NIO 编程复杂,而且在生产环境中评价不高
3. NIO 的替代品 Netty 框架机制基于事件,而且属于对NIO的再次封装,肯能不适合

**目前解决方案**

1. 关于套接字
 * 使用JNI  JNA   JavaCpp 等技术 内嵌 C 语言解决 java 无法操作底层问题
    + 缺点 : JNI JNA 学习成本高,  JavaCpp 性能未知
 * 通过套接字池方法
    + 缺点 : 不知道 过于庞大的套接字池 是否会影响系统的运行

2. 关于IO
 * 确认使用NIO, 因为Netty 基于事件的模式不符合我的需求

具体思路:

*****


> 2017-01-30 20:45

由于查文档发现原生的JavaNIO 有很大的问题，而且编程要求太高，所以放弃了。可以说是一种甩锅行为，现在也要用到框架了

目前暂时决定是用 `Netty` 框架，不过这个，希望这个框架简单点吧

*****

> 2017.1.26 9:06

还在测试第一种跳变方法，目前发现是 服务器端没有办法发送数据

发现一个细节错误，  InetSockaddr的比较 要用equals 函数，这个解决了资源占用问题

> 2017.1.24 19:47

新的思路：

关于内存占用问题，可能是每次跳变都需要新建一个`InetSocketAddr` 对象，然而Java的内存回收机制是不可靠的，所以寻求以下的方法

1. 把`InetSocketAddr`对象复用，但是`InetSocketAddr`对象好像没有`set`方法
2. 把可用的情况都申请一个`InetSocketAddr`并且存放，这样就不用每次跳变都申请一个对象。

这里考虑到C和Java的差别

**************************************

> 2017.1.24 10:25

**第一次跳变方法总结**

第一次跳变方法的思路：

1. 开启一个子线程，然后子线程进行同步
2. 主线程只是调用send，等函数发送信息

**情况**

无法正常通信，而且出现了资源占用过高情况

失败原因猜想：

1. 子线程同步时候多次绑定一个相同的端口，直接导致了通信失败（端口被断开后有可能不能马上再次被使用）
2. 子线程负责同步，主线程负责IO，但是两个线程同步问题没有考虑进去


******************************

> 2017.1.23 11:31

没有尝试修复前面的问题，而是接着开发测试代码，查看一下端口重复绑定会不会影响

结果是无法正常通信，同步策略需要更改

******************************

> 2017.1.23 11:14

跳变类依然出现端口重复绑定错误

```
java.net.SocketException: Already bound
	at sun.nio.ch.Net.translateToSocketException(Net.java:125)
	at sun.nio.ch.DatagramSocketAdaptor.bind(DatagramSocketAdaptor.java:93)
	at Transport.Jump_UDP.run(Jump_UDP.java:110)
	at java.lang.Thread.run(Thread.java:745)
```

测试发现虽然get到了不同的value值，但是通过这个值算出来的端口，ip都没有改变，因此出现了重复绑定的问题
